<!-- build time:Sat May 07 2022 03:03:27 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="余弦の博客" href="https://ysx.cosine.ren/rss.xml"><link rel="alternate" type="application/atom+xml" title="余弦の博客" href="https://ysx.cosine.ren/atom.xml"><link rel="alternate" type="application/json" title="余弦の博客" href="https://ysx.cosine.ren/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="计算机组成原理"><link rel="canonical" href="https://ysx.cosine.ren/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89%E5%A4%9A%E5%B1%82%E6%AC%A1%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8/"><title>计算机组成原理复习总结（三）多层次的存储器 - CS 基础 - 笔记 | cosine = 余弦の博客 = WA 的一声就哭了</title><meta name="generator" content="Hexo 6.1.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline"><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89%E5%A4%9A%E5%B1%82%E6%AC%A1%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8" class="link external" itemprop="url">计算机组成原理复习总结（三）多层次的存储器<i class="ic i-link-alt"></i></a></h1><div class="meta"><span class="item" title="创建时间：2021-06-17 20:15:02"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-06-17T20:15:02+08:00">2021-06-17</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>13k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>12 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">cosine</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/img/header_img/lml_bg.jpg"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/note/" itemprop="item" rel="index" title="分类于 笔记"><span itemprop="name">笔记</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/note/cs-basics/" itemprop="item" rel="index" title="分类于 CS 基础"><span itemprop="name">CS 基础</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="cn"><link itemprop="mainEntityOfPage" href="https://ysx.cosine.ren/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89%E5%A4%9A%E5%B1%82%E6%AC%A1%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/avatar.jpg"><meta itemprop="name" content="cos"><meta itemprop="description" content="WA 的一声就哭了, 愿岁并谢，与友长兮"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="余弦の博客"></span><div class="body md" itemprop="articleBody"><h1 id="第三章-多层次的存储器"><a class="anchor" href="#第三章-多层次的存储器">#</a> 第三章 多层次的存储器</h1><p>本章内容较多，主要包括各种存储器及存储方式存储器，其中重点为存储器基本概念、DRAM、SRAM、cache、命中率与平均访问时间、主存与 cache 映射方式和虚存等</p><h2 id="31-存储器概述"><a class="anchor" href="#31-存储器概述">#</a> 3.1 存储器概述</h2><h3 id="311-存储器的分类"><a class="anchor" href="#311-存储器的分类">#</a> 3.1.1 存储器的分类</h3><ul><li>存储器是计算机系统中的记忆设备，用来存放程序和数据。</li><li><strong>存储介质</strong>：目前主要采用<strong>半导体器件</strong>和<strong>磁性材料</strong>。</li><li><strong>存储位元</strong>：一个双稳态半导体电路或一个 CMOS 晶体管或磁性材料的存储元，均可以存储一位二进制代码。这个二进制代码位是存储器中最小的存储单位，称为<strong>存储位元</strong></li><li><strong>存储单元</strong>：由若干个存储位元组成一个存储单元。由许多存储单元组成一个存储器。</li></ul><p>根据存储材料的性能和使用方法的不同，存储器有不同分类方法<br>（1）根据<strong>存储介质</strong>分类，分为<strong>磁表面</strong> /<strong> 半导体</strong>存储器<br>（2）根据<strong>存取方式</strong>分类，分为<strong>随机</strong> /<strong> 顺序</strong>存取（磁带）<br>（3）根据<strong>读写功能</strong>分类，分为只读存储器 (<strong>ROM</strong>) 和随机读写存储器 (<strong>RAM</strong>)<br>（4）根据<strong>信息的易失性</strong>分类：分为<strong>易失性</strong>和<strong>非易失性</strong>的<br>（5）根据<strong>存储器系统中的作用</strong>分类：分为<strong>主 / 辅 / 缓 / 控</strong></p><h3 id="312-存储器的分级"><a class="anchor" href="#312-存储器的分级">#</a> 3.1.2 存储器的分级</h3><p>当前存储器的特点：</p><ul><li><p>速度快的存储器价格贵，容量小；</p></li><li><p>价格低的存储器速度慢，容量大。<br>在计算机存储器体系结构设计时，我们希望存储器的容量大、速度快、价格低，那么在存储器系统设计时，应当在<strong>存储器容量，速度和价格方面</strong>的因素作折中考虑，建立了<strong>多级存储器体系结构</strong>，如下图所示<br><img data-src="https://img-blog.csdnimg.cn/20210615183839569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>高速缓冲存储器简称<strong> cache</strong>，它是计算机系统中的一个<strong>高速小容量半导体存储器</strong></p></li><li><p>主存储器简称<strong>主存</strong>，是计算机系统的<strong>主要存储器</strong>，用来存放计算机运行期间的大量程序和数据。</p></li><li><p>外存储器简称<strong>外存</strong>，它是<strong>大容量辅助存储器</strong>。</p></li></ul><h3 id="313主存储器的技术指标"><a class="anchor" href="#313主存储器的技术指标">#</a> 3.1.3 主存储器的技术指标</h3><ul><li><strong>字存储单元</strong>：存放一个机器字的存储单元，相应的单元地址叫字地址。</li><li><strong>字节存储单元</strong>：存放一个字节的单元，相应的地址称为字节地址。</li><li><strong>存储容量</strong>：指一个存储器中可以容纳的存储单元总数。存储容量越大，能存储的信息就越多。</li><li><strong>存取时间</strong>（又称存储器访问时间）：指一次读操作命令发出到该操作完成，将数据读出到数据总线上所经历的时间。通常取写操作时间等于读操作时间，故称为存储器存取时间。</li><li><strong>存储周期</strong>：指连续启动两次读操作所需间隔的最小时间。通常，存储周期略大于存取时间，其时间单位为 ns。</li><li><strong>存储器带宽</strong>：单位时间里存储器所存取的信息量，通常以位 / 秒或字节 / 秒做度量单位。</li></ul><h2 id="32-sram存储器静态读写存储器"><a class="anchor" href="#32-sram存储器静态读写存储器">#</a> 3.2 SRAM 存储器（静态读写存储器）</h2><p>目前广泛使用的主存（内部存储器）是半导体存储器。根据信息存储的机理不同可以分为两类</p><ul><li>静态读写存储器 (SRAM)：<strong>存取速度快</strong>、但存储容量不如 DRAM 大</li><li>动态读写存储器 (DRAM)：<strong>存取速度略慢</strong>、存储容量比 SRAM 大。</li></ul><h3 id="321-基本的静态存储元阵列"><a class="anchor" href="#321-基本的静态存储元阵列">#</a> 3.2.1 基本的静态存储元阵列</h3><ul><li><strong>存储位元</strong>：一个锁存器（触发器）。只要直流供电电源一直加到这个记忆电路上，它就无限期地保持记忆的 1 状态或 0 状态。如果电源<strong>断电，那么存储的数据（1 或 0）就会丢失</strong>。</li><li><strong>三组信号线（重点）</strong>：<strong>地址线</strong>、<strong>数据线</strong>（行线、列线）、<strong>控制线</strong></li><li><strong>地址线</strong>：若为 6 条，则指定了存储器的容量为 2<sup>6</sup> = 64 个<strong>存储单元</strong></li><li><strong>数据线</strong>：若为 4 条，则制定了存储器的<strong>字长</strong>为 4 位，因此<strong>存储位元总数为 64×4 = 256</strong>。</li><li><strong>控制线</strong>：R/~W 控制线，指定了对存储器进行读还是写</li></ul><p>地址译码器输出有 64 条选择线，我们称之为行线，它的作用是打开每个存储位元的输入与非门。<br><img data-src="https://img-blog.csdnimg.cn/20210615184422200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="322-基本的sram逻辑结构"><a class="anchor" href="#322-基本的sram逻辑结构">#</a> 3.2.2 基本的 SRAM 逻辑结构</h3><ul><li><p>SRAM 芯片大多采用<strong>双译码</strong>方式，以便组织更大的存储容量。</p></li><li><p>采用了二级译码：将地址分成 x 向、y 向两部分如图所示。<br><img data-src="https://img-blog.csdnimg.cn/20210615184743114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>存储体（256 行 ×128 列 ×8 位）存储阵列</p></li><li><p>地址译码器</p><ul><li>采用双译码的方式（减少选择线的数目）。</li><li>A0~ A7 为行地址译码线</li><li>A8~A14 为列地址译码线</li></ul></li><li><p>双向数据线为 8 条</p></li></ul><h3 id="323-读写周期波形图"><a class="anchor" href="#323-读写周期波形图">#</a> 3.2.3 读 / 写周期波形图</h3><p><img data-src="https://img-blog.csdnimg.cn/20210615185224497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20210615185404689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>例 1: 图为 SRAM 的写入时序图。其中 R/W 是读 / 写命令控制线，当 R/W 线为低电平时，存储器按给定地址把数据线上的数据写入存储器。请指出图中写入时序中的错误，并画出正确的写入时序图。<br><img data-src="https://img-blog.csdnimg.cn/20210615185719822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>解：写入存储器的时序信号必须同步。通常，当 R/W 线加负脉冲时，地址线和数据线的电平必须是稳定的。当 R/W 线达到低电平时，数据立即被存储。因此，当 R/W 线处于低电平时，如果数据线改变了数值，那么存储器将存储新的数据⑤。同样，当 R/W 线处于低电平时地址线如果发生了变化，那么同样数据将存储到新的地址②或③。<br>正确的写入时序图见图 (b)。</p><h2 id="33-dram存储器动态读写存储器"><a class="anchor" href="#33-dram存储器动态读写存储器">#</a> 3.3 DRAM 存储器（动态读写存储器）</h2><p>SRAM 存储器的存储元是一个触发器，它具有两个稳定的状态。<br>而 DRAM 存储器的存储元是由<strong>一个 MOS 晶体管和电容器</strong>组成的记忆电路。<br>MOS 管做为开关使用所存储的信息为 1 或 0 则是由<strong>电容器上的电荷量</strong>来体现。</p><ul><li>当电容器<strong>充满电荷</strong>时，代表<strong>存储了 1</strong>；</li><li>当电容器放电<strong>没有电荷</strong>时，代表<strong>存储了 0</strong></li></ul><p>DRAM 与 SRAM 不同的是</p><ul><li>增加了<strong>行地址锁存器</strong>和<strong>列地址锁存器</strong>。由于 DRAM 存储器容量很大，地址线宽度相应要增加，这势必增加芯片地址线的管脚数目。为避免这种情况，采取的办法是<strong>分时传送地址码</strong>。若地址总线宽度为 10 位，先传送地址码 A0～A9，由行选通信号 RAS 打入到行地址锁存器；然后传送地址码 A10～A19，由列选通信号 CAS 打入到列地址锁存器。芯片内部两部分合起来，地址线宽度达 20 位，存储容量为 1M×4 位。</li><li>增加了<strong>刷新计数器</strong>和<strong>相应的控制电路</strong>。<strong>DRAM 读出后必须刷新</strong>，而未读写的存储元也要定期刷新，而且要<strong>按行刷新</strong>，所以<strong>刷新计数器的长度等于行地址锁存器</strong>。刷新操作与读 / 写操作是交替进行的，所以通过 2 选 1 多路开关来提供刷新行地址或正常读 / 写的行地址。</li></ul><h3 id="333-读写周期-刷新周期重点"><a class="anchor" href="#333-读写周期-刷新周期重点">#</a> 3.3.3 读 / 写周期、刷新周期（重点）</h3><h4 id="读写周期"><a class="anchor" href="#读写周期">#</a> 读 / 写周期</h4><p>读周期、写周期的定义是从行选通信号 RAS 下降沿开始，到下一个 RAS 信号的下降沿为止的时间，也就是连续两个读周期的时间间隔。<strong>通常为控制方便，读周期和写周期时间相等。</strong><br><img data-src="https://img-blog.csdnimg.cn/20210615192722518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="刷新周期"><a class="anchor" href="#刷新周期">#</a> 刷新周期</h4><p>DRAM 存储位元是基于电容器上的电荷量存储，这个电荷量随着时间和温度而减少，因此必须<strong>定期地刷新</strong>，以保持它们原来记忆的正确信息。<br>刷新操作有两种刷新方式： 集中式刷新与分散式刷新</p><h5 id="集中式刷新"><a class="anchor" href="#集中式刷新">#</a> 集中式刷新</h5><p>DRAM 的<strong>所有行在每一个刷新周期中都被刷新</strong>。 例如刷新周期为 8ms 的内存来说，所有行的集中式刷新必须每隔 8ms 进行一次。为此将 8ms 时间分为两部分：前一段时间进行正常的读 / 写操作，后一段时间（8ms 至正常读 / 写周期时间）做为集中刷新操作时间。</p><h5 id="分散式刷新"><a class="anchor" href="#分散式刷新">#</a> 分散式刷新</h5><p><strong>每一行的刷新插入到正常的读 / 写周期之中</strong>。 例如 p70 图 3.7 所示的 DRAM 有 1024 行，如果刷新周期为 8ms，则每一行必须每隔 8ms÷1024=7.8us 进行一次。<strong>分散式刷新不存在死时间！</strong></p><h2 id="34-只读存储器rom和闪速存储器flash"><a class="anchor" href="#34-只读存储器rom和闪速存储器flash">#</a> 3.4 只读存储器（ROM）和闪速存储器 (FLASH)</h2><h3 id="1-掩模rommrom"><a class="anchor" href="#1-掩模rommrom">#</a> 1、掩模 ROM（MROM)</h3><p><strong>存储内容固定的 ROM</strong>，由生产厂家提供产品。 一旦 ROM 芯片做成，就不能改变其中的存储内容 用于存储广泛使用的具有标准功能的程序或数据，或用户定做的具有特殊功能的程序或数据 （这些程序或数据均使用二进制码）</p><ul><li><strong>优点：可靠性和集成度高，价格便宜</strong></li><li><strong>缺点：不能重写</strong></li></ul><h3 id="2-可编程rom"><a class="anchor" href="#2-可编程rom">#</a> 2、可编程 ROM</h3><p>用户可修改其存储内容<br>根据编程操作的不同，可编程 ROM 可分为</p><ul><li><strong>一次可编程 (PROM)</strong><br>特点：用户可自行改变产品中某些存储元，用户<strong>可编程一次</strong>。<br>优点：可以根据用户需要编程<br>缺点：只能一次性改写</li><li>光擦可编程 (EPROM)<br>存储内容可以根据需要写入，当需要更新时将原存储内容抹去，再写入新的内容。</li><li>电擦可编程 (EEPROM)</li></ul><h3 id="3-flash存储器"><a class="anchor" href="#3-flash存储器">#</a> 3、FLASH 存储器</h3><ul><li>FLASH 存储器也翻译成<strong>闪速存储器</strong>，它是<strong>高密度非易失性</strong>的读 / 写存储器。</li><li>高密度意味着它具有巨大比特数目的存储容量。</li><li>非易失性意味着存放的数据在没有电源的情况下可以长期保存。</li><li>既有 RAM 的优点，又有 ROM 的优点，称得上是存储技术划时代的进展。</li></ul><p>FLASH 存储器的基本操作有编程操作、读取操作、擦除操作</p><h2 id="35-并行存储器重点"><a class="anchor" href="#35-并行存储器重点">#</a> 3.5 并行存储器（重点）</h2><ul><li>由于 CPU 和主存储器之间在速度上是不匹配的，这种情况成为限制高速计算机设计的主要问题。</li><li>为了<strong>提高 CPU 和主存之间的数据传输率</strong>，除了主存采用更高速的技术来缩短读出时间外，还可以采用<strong>并行技术的存储器</strong>。</li><li>双端口存储器 ——<strong> 空间并行</strong>技术</li><li>多模块交叉存储器 ——<strong> 时间并行</strong>技术</li></ul><h3 id="351-双端口存储器"><a class="anchor" href="#351-双端口存储器">#</a> 3.5.1 双端口存储器</h3><h4 id="1-双端口存储器的逻辑结构"><a class="anchor" href="#1-双端口存储器的逻辑结构">#</a> 1、双端口存储器的逻辑结构</h4><p>双端口存储器由于<strong>同一个存储器具有两组相互独立的读写控制电路</strong>而得名。<br>由于进行并行的独立操作，因而是一种高速工作的存储器，在科研和工程中非常有用。<br>举例说明，双端口存储器 IDT7133 的逻辑框图。如下页图。<br><img data-src="https://img-blog.csdnimg.cn/20210615194420976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-无冲突读写控制"><a class="anchor" href="#2-无冲突读写控制">#</a> 2、无冲突读写控制</h4><ul><li>当两个端口的<strong>地址不相同</strong>时，在两个端口上进行读写操作，<strong>一定不会发生冲突</strong>。</li><li>当任一端口被选中驱动时，就可对整个存储器进行存取，每一个端口都有自己的片选控制 (CE) 和输出驱动控制 (OE)。</li><li>读操作时，端口的 OE (低电平有效) 打开输出驱动器，由存储矩阵读出的数据就出现在 I/O 线上。</li></ul><h4 id="3-有冲突读写控制"><a class="anchor" href="#3-有冲突读写控制">#</a> 3、有冲突读写控制</h4><ul><li>当<strong>两个端口同时存取存储器同一存储单元</strong>时，便发生读写冲突。</li><li>为解决此问题，特设置了 BUSY 标志。在这种情况下，片上的<strong>判断逻辑</strong>可以决定对哪个端口优先进行读写操作，而对<strong>另一个</strong>被延迟的端口置 BUSY 标志 (BUSY 变为低电平)，即<strong>暂时关闭</strong>此端口。</li></ul><h3 id="352多模块交叉存储器"><a class="anchor" href="#352多模块交叉存储器">#</a> 3.5.2 多模块交叉存储器</h3><h4 id="1-存储器的模块化组织"><a class="anchor" href="#1-存储器的模块化组织">#</a> 1、存储器的模块化组织</h4><p>一个由若干个模块组成的主存储器是线性编址的。这些地址在各模块中如何安排，有两种方式：一种是<strong>顺序方式</strong>，一种是<strong>交叉方式</strong><img data-src="https://img-blog.csdnimg.cn/20210615194839717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>[例] M0－M3 共四个模块，则每个模块 8 个字<br><strong>顺序方式</strong>：　　M0：0-7<br>M1：8-15<br>M2：16-23<br>M3：24-31<br>5 位地址组织如下： X X X X X<br><strong>高位选模块，低位选块内地址</strong></p><ul><li>特点：某个模块进行存取时，其他模块不工作。</li><li>优点：某一模块出现故障时，其他模块可以照常工作，通过增添模块来扩充存储器容量比较方便。</li><li>缺点：各模块串行工作，存储器的带宽受到了限制。</li></ul><p>[例] M0－M3 共四个模块，则每个模块 8 个字<br><strong>交叉方式</strong>：　　　M0：0，4，…… 除以 4 余数为 0<br>M1：1，5，…… 除以 4 余数为 1<br>M2：2，6，…… 除以 4 余数为 2<br>M3：3，7，…… 除以 4 余数为 3<br>5 位地址组织如下： X X X X X<br><strong>高位选块内地址，低位选模块</strong></p><ul><li>特点：连续地址分布在相邻的不同模块内，<strong>同一个模块内的地址都是不连续的</strong>。</li><li>优点：对连续字的成块传送可实现多模块流水式并行存取，大大提高存储器的带宽。使用场合为成批数据读取。</li></ul><h4 id="2-多模块交叉存储器的基本结构"><a class="anchor" href="#2-多模块交叉存储器的基本结构">#</a> 2、多模块交叉存储器的基本结构</h4><p>下图为四模块交叉存储器结构框图。主存被分成 4 个相互独立、容量相同的模块 M0，M1，M2，M3，每个模块都有自己的读写控制电路、地址寄存器和数据寄存器，各自以等同的方式与 CPU 传送信息。在理想情况下，如果程序段或数据块都是连续地在主存中存取，那么将大大提高主存的访问速度。<br><img data-src="https://img-blog.csdnimg.cn/20210615195535955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="36-cache存储器重点"><a class="anchor" href="#36-cache存储器重点">#</a> 3.6 cache 存储器（重点）</h2><h3 id="361-cache基本原理"><a class="anchor" href="#361-cache基本原理">#</a> 3.6.1 cache 基本原理</h3><h4 id="1-cache的功能"><a class="anchor" href="#1-cache的功能">#</a> 1、cache 的功能</h4><ul><li>为了解决<strong> CPU 和主存之间的速度不匹配</strong>问题而采用的一项重要技术</li><li>介于 CPU 和主存之间的<strong>小容量高速</strong>缓冲存储器</li><li>基于程序访问的<strong>局部性原理</strong></li><li>能高速地向 CPU 提供指令和数据，从而加快了程序的执行速度。</li><li>为追求高速，包括管理在内的<strong>全部功能由硬件实现</strong>。</li></ul><h5 id="程序访问的局部性原理"><a class="anchor" href="#程序访问的局部性原理">#</a> 程序访问的局部性原理</h5><p>在一个较短的时间间隔内，程序对局部范围的存储器地址的频繁访问，而对局部范围以外的地址访问甚少的现象，称为程序的局部性。<br>一般 cache 采用高速的 SRAM 制作，其价格比主存贵，但因其容量远小于主存，因此能较好地解决速度和价格的矛盾。</p><h4 id="2-cache基本原理"><a class="anchor" href="#2-cache基本原理">#</a> 2、cache 基本原理</h4><ul><li>cache 的<strong>设计依据</strong>：CPU 这次访问过的数据，下次有很大的可能也是访问附近的数据。(<strong>程序访问的局部性</strong>)</li><li>CPU 与 Cache 之间的数据交换是<strong>以字为单位</strong></li><li>主存与 Cache 之间的数据交换是<strong>以块为单位</strong></li><li>CPU 读取内存中一个字时，便发出此字的内存地址到 Cache 和主存。此时 Cache 控制逻辑<strong>依据地址判断</strong>此字当前是否在 Cache 中。<strong>若是，此字立即传送给 CPU; 若非，则用主存读周期把此字从主存读出送到 CPU，与此同时，把含有这个字的整个数据块从主存读出送到 cache 中。</strong></li></ul><p>下图中，cache 分为 4 行，每行 4 个字。分配给 cache 的地址存在一个<strong>相联存储器 CAM</strong> 中，它是按内容寻址的存储器。当 CPU 执行访存指令时，就把所要访问的字的地址送到 CAM 和主存。送到 CAM 的地址按内容进行比较判断，若该字不在 cache 中，则从主存找到这个字，并将该字从主存传送到 CPU。与此同时，<strong>把包含该字的前后相继的 4 个字的一行数据送入 cache</strong>。<br><img data-src="https://img-blog.csdnimg.cn/20210615200249409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="3-cache结构"><a class="anchor" href="#3-cache结构">#</a> 3、cache 结构</h4><ul><li>Cache 的数据块称为行，用 L<sub>i</sub> 表示，其中 i=0, 1, … , m-1</li><li>主存的数据块称为块，用 B<sub>j</sub> 表示，其中 j=0, 1, … , n-1</li><li>行与块是等长的，每行 (块) 包含 k 个主存字</li><li>Cache 由数据存储器和标签存储器组成<ul><li>数据存储器：存放主存一个数据块的数据</li><li>标签存储器：保存数据所在主存的<strong>地址信息</strong><br><img data-src="https://img-blog.csdnimg.cn/20210615200628318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li></ul><h4 id="4-命中与未命中"><a class="anchor" href="#4-命中与未命中">#</a> 4、命中与未命中</h4><p><strong>命中</strong>：</p><ul><li>主存块<strong>调入</strong>缓存</li><li>主存块与缓存块<strong>建立</strong>了对应关系</li><li>用<strong>标记记录</strong>与某缓存块建立了对应关系的主存块号</li></ul><p><strong>未命中</strong>：</p><ul><li>主存块<strong>未调入</strong>缓存</li><li>主存块与缓存块<strong>未建立</strong>对应关系</li></ul><p><strong>命中率</strong>：</p><ul><li>从 CPU 来看，增加一个 cache 的目的，就是在性能上<strong>使主存的平均读出时间尽可能接近 cache 的读出时间</strong>。</li><li>为了达到这个目的，在所有的存储器访问中由 cache 满足 CPU 需要的部分应占很高的比例，即 cache 的命中率应接近于 1。</li><li>在一个程序执行期间，设 <strong>Nc</strong> 表示<strong> cache 完成存取的总次数</strong>，<strong>Nm</strong> 表示<strong>主存完成存取的总次数</strong>，<strong>h</strong> 定义为<strong>命中率</strong>，则有 <strong>h = Nc /（ Nc + Nm)</strong></li><li>若<strong> Tc</strong> 表示<strong>命中时的 cache 访问时间</strong>，<strong>Tm</strong> 表示<strong>未命中时的主存访问时间</strong>，<strong>1-h</strong> 表示<strong>未命中率</strong>，则 cache / 主存系统的<strong>平均访问时间 Ta</strong> 为： $$T_a = h * T_c +(1-h) * T_m$$</li><li>我们追求的目标是，以较小的硬件代价使 cache / 主存系统的平均访问时间 T<sub>a</sub> 越接近 T<sub>c</sub> 越好。</li><li>设<strong> r 表示主存慢于 cache 的倍率</strong> $$r = \frac {T_m}{T_c}$$<br><strong>e 表示访问效率</strong>，则有</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>e</mi><mo>=</mo><msub><mi>T</mi><mi>c</mi></msub><mi mathvariant="normal">/</mi><msub><mi>T</mi><mi>a</mi></msub><mspace linebreak="newline"></mspace><mo>=</mo><mfrac><msub><mi>T</mi><mi>c</mi></msub><mrow><mi>h</mi><mo>∗</mo><msub><mi>T</mi><mi>c</mi></msub><mo>+</mo><mtext>（</mtext><mn>1</mn><mo>−</mo><mi>h</mi><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>T</mi><mi>m</mi></msub></mrow></mfrac><mspace linebreak="newline"></mspace><mo>=</mo><mfrac><mn>1</mn><mrow><mi>h</mi><mo>+</mo><mtext>（</mtext><mn>1</mn><mo>−</mo><mi>h</mi><mtext>）</mtext><mo>∗</mo><mi>r</mi></mrow></mfrac><mspace linebreak="newline"></mspace><mo>=</mo><mfrac><mn>1</mn><mrow><mi>r</mi><mo>+</mo><mtext>（</mtext><mn>1</mn><mo>−</mo><mi>r</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>h</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">e = T_c / T_a \\ = \frac{T_c} {h*T_c +（1-h)*T_m }\\ = \frac{1} {h+（1-h）*r}\\ = \frac{1} {r+（1-r)*h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:.36687em;vertical-align:0"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.29633em;vertical-align:-.936em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord cjk_fallback">（</span><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.936em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:.36687em;vertical-align:0"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-.7693300000000001em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord cjk_fallback">（</span><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathnormal">h</span><span class="mord cjk_fallback">）</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.7693300000000001em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:.36687em;vertical-align:0"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.25744em;vertical-align:-.936em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord cjk_fallback">（</span><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathnormal">h</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.936em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>即 $$e = \frac {1} {r+（1-r)*h}$$</p><ul><li>由表达式看出，为提高访问效率，<strong>命中率 h 越接近 1 越好，r 值以 5—10 为宜</strong>，不宜太大。</li><li>命中率 h 与程序的行为、cache 的容量、组织方式、块的大小有关。</li></ul><p>例 6:CPU 执行一段程序时，cache 完成存取的次数为 1900 次，主存完成存取的次数为 100 次，已知 cache 存取周期为 50ns，主存存取周期为 250ns，求 cache / 主存系统的效率和平均访问时间。<br>解： h= Nc /（ Nc + Nm) =1900/(1900+100)=0.95<br>r= tm / tc =250ns/50ns=5<br>e=1/(r+(1-r)h)=1/(5+(1-5)×0.95=83.3%<br>e= tc /ta<br>ta= tc /e=50ns/0.833=60ns</p><h3 id="362-主存与cache的地址映射"><a class="anchor" href="#362-主存与cache的地址映射">#</a> 3.6.2 主存与 cache 的地址映射</h3><ul><li>与主存相比，<strong>cache 的容量很小，保存的内容只是主存内容的一个子集</strong>，且 cache 与主存的数据交换是以块为单位。</li><li>为了把主存块放到 cache 中，必须应用某种方法把主存地址定位到 cache 中，称为<strong>地址映射</strong>。</li><li>无论选择哪种映射方式，都要把主存和 cache 划分为同样大小的 “块”。</li><li>选择哪种映射方式，要考虑：<ul><li>硬件是否容易实现</li><li>地址变换的速度是否快</li><li>主存空间的利用率是否高</li><li>主存装入一块时，发生冲突的概率</li></ul></li><li>以下我们介绍三种映射方法<ul><li><strong>全相联映射、直接映射、组相联映射</strong></li></ul></li></ul><h4 id="全相联映射方式"><a class="anchor" href="#全相联映射方式">#</a> 全相联映射方式</h4><p>主存中一个块的地址 (块号) 与块的内容 (字) 一起存于 cache 的行中，其中块地址存于 cache 行的标记部分主存的每一块都可映射到 cache 任意一行中<br><img data-src="https://img-blog.csdnimg.cn/20210615202323953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>CPU 访存指令指定一个内存地址 (由块号和字组成)</li><li>为了快速检索，主存地址中的块号与 Cache 中所有行的标记同时在比较器中进行比较。相同表示块号命中，按字地址从 cache 中读取一个字；如果块号未命中，则按内存地址从主存中读取这个字</li><li>转换公式<ul><li>主存地址长度＝(s+w) 位</li><li>寻址单元数＝2<sup>w</sup> 个字或字节</li><li>块大小＝行大小＝2<sup>w</sup> 个字或字节</li><li>主存的块数＝2<sup>s</sup></li><li>标记大小＝s 位</li><li>cache 的行数＝不由地址格式确定</li></ul></li><li>优点：可使主存的一个块直接拷贝到 cache 中的任意一行上，<strong>非常灵活</strong>，cache 空间的<strong>利用率高</strong>，cache 的<strong>块冲突概率低</strong></li><li>缺点：<strong>比较器难实现</strong>，需要一个访问速度很快代价高的相联存储器，<strong>只适合于小容量 cache</strong> 采用</li></ul><h4 id="直接映射方式"><a class="anchor" href="#直接映射方式">#</a> 直接映射方式</h4><ul><li>一种<strong>多对一</strong>的映射关系</li><li><strong>一个主存块只能拷贝到 cache 的一个特定行位置上</strong></li><li>Cache 的行号 i 与主存的块号 j 有如下函数关系<ul><li>i= j mod m （m 为 cache 的总行数）</li><li>主存第 j 块内容拷贝到 Cache 的 i 行<br><img data-src="https://img-blog.csdnimg.cn/20210615202913451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li></ul><h5 id="直接映射方式的检索过程"><a class="anchor" href="#直接映射方式的检索过程">#</a> 直接映射方式的检索过程</h5><ul><li>利用行号选择相应行；</li><li>把行标记与 CPU 访问地址进行比较。相同表示命中，访问 Cache；如果没有命中，访问主存，并将相应块写入 Cache<br><img data-src="https://img-blog.csdnimg.cn/20210616090434170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>转换公式</strong></li><li>主存地址长度 = (s+w) 位</li><li>寻址单元数 = 2<sup>s+w</sup> 个字或字节</li><li>块大小 = 行大小 = 2<sup>w</sup> 个字或字节</li><li>主存的块数 = 2<sup>s</sup></li><li>cache 的行数 = m =2<sup>r</sup></li><li>标记大小 =(s-r) 位</li></ul><p>优点：比较电路少 m 倍线路，所以<strong>硬件实现简单</strong>，Cache 地址为主存地址的低几位，不需变换。<br>缺点：<strong>冲突概率高</strong><br>应用场合：适合<strong>大容量 Cache</strong></p><h4 id="组相联映射方式"><a class="anchor" href="#组相联映射方式">#</a> 组相联映射方式</h4><p>全相联映射和直接相联映射两种方式的优缺点正好相反，从存放位置的灵活性和命中率来看，前者为优；从比较器电路简单及硬件投资来说，后者为佳</p><ul><li>将 cache 分成 u 组，每组 v 行</li><li>主存块与 cache 组之间采用直接映射方式，即<strong>主存块存放到哪个组是固定</strong>的；每个组内部的行之间则采用全相联的映射方式，即<strong>主存块可以映射到 cache 固定组的任一行</strong>中</li><li>Cache 组号 q 与主存块号 j 的关系为<ul><li>q= j mod u (u 为 cache 的总组数)</li><li>主存第 j 块内容拷贝到 Cache 的 q 组中的某行</li></ul></li><li>地址变换<ul><li>设主存地址 x，看是不是在 cache 中，先 y= x mod u，则在 y 组中一次查找</li></ul></li></ul><p>比全相联容易实现，冲突低<br>若 v=1，则为直接相联映射方式<br>若 u=1，则为全相联映射方式<br>v 的取值一般比较小， 一般是 2 的幂 (典型值是 2，4，8，16)，称之为 v 路组相联 cache。<img data-src="https://img-blog.csdnimg.cn/20210616091621259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>转换公式</strong></p><ul><li>主存地址长度＝(s+w) 位</li><li>寻址单元数＝2<sup>s+w</sup> 个字或字节</li><li>块大小＝行大小＝2<sup>w</sup> 个字或字节</li><li>主存的块数＝2<sup>s</sup></li><li>每组的行数＝v</li><li>组数 u＝2<sup>d</sup></li><li>cache 的行数＝uv</li><li>标记大小＝(s-d) 位</li></ul><p>p96 例 6：一组相联 cache 由 64 个行组成，每组 4 行，主存储器包含 4K 个块，每块 128 字，请表示内存地址的格式。<br>解：块大小 = 行大小 = 2<sup>w</sup> 个字 = 128 = 2<sup>7</sup> 所以 w = 7<br>每组的行数 = v = 4<br>cache 的行数 = uv = 64，故组数 u = 16<br>u = 2<sup>d</sup> = 16 = 2<sup>4</sup>，故 d = 4<br>主存的块数 = 2<sup>s</sup> = 4K = 2<sup>2</sup> * 2<sup>10</sup> = 2<sup>12</sup>，故 s = 12<br>地址格式如下：</p><table><thead><tr><th>标记 s-d</th><th>组号 d</th><th>字号 w</th></tr></thead><tbody><tr><td>8 位</td><td>4 位</td><td>7 位</td></tr></tbody></table><h3 id="363-替换策略"><a class="anchor" href="#363-替换策略">#</a> 3.6.3 替换策略</h3><ul><li>Cache 工作原理要求尽量保存最新数据。</li><li>当一个新的内存块需要拷贝到 cache，而允许存放此块的行位置都被其它主存块占满时，就需要替换。</li><li>直接映射方式：<strong>直接替换</strong></li><li>全相连和组相连方式：从允许存放新主存块的若干特定行中选取一行换出。</li><li>替换常用的三种算法:<ul><li>最不经常使用 (LFU) 算法</li><li>近期最少使用 (LRU) 算法</li><li>随机替换</li></ul></li></ul><h4 id="最不经常使用lfu算法"><a class="anchor" href="#最不经常使用lfu算法">#</a> 最不经常使用 (LFU) 算法</h4><ul><li>将<strong>一段时间内被访问次数最少的那行数据换出</strong>。</li><li><strong>每行设置一个计数器</strong>。新行建立后从 0 开始计数，每访问一次，被访行的计数器增 1。当需要替换时，将计数值最小的行换出，同时将这些行的计数器都清零</li><li>这种算法，计数周期限定在对特定行两次替换之间的间隔时间内，<strong>不能反映近期 cache 的访问情况</strong></li></ul><h4 id="近期最少使用lru算法"><a class="anchor" href="#近期最少使用lru算法">#</a> 近期最少使用 (LRU) 算法</h4><ul><li>将<strong>近期内长久未被访问过的行换出</strong>。</li><li>每行也设置一个计数器，cache 每命中一次，命中行计数器清零，其他各行计数器增 1。当需要替换时，将计数值最大的行换出。</li><li>这种算法保护了刚拷贝到 cache 中的新数据行，<strong>有较高的命中率</strong></li></ul><h4 id="随机替换"><a class="anchor" href="#随机替换">#</a> 随机替换</h4><ul><li>从特定的行位置中<strong>随机地选取一行</strong>换出</li><li>这种策略在<strong>硬件上容易实现</strong>，且<strong>速度也比前两种策略快</strong></li><li>缺点是随意换出的数据很可能马上又要使用，从而<strong>降低命中率和 cache 工作效率</strong>。但这个不足随着 cache 容量增大而减小。</li><li></li></ul><h2 id="37-虚拟存储器重点"><a class="anchor" href="#37-虚拟存储器重点">#</a> 3.7 虚拟存储器（重点）</h2><h3 id="371-虚拟存储器的基本概念"><a class="anchor" href="#371-虚拟存储器的基本概念">#</a> 3.7.1 虚拟存储器的基本概念</h3><h4 id="1-实地址与虚地址"><a class="anchor" href="#1-实地址与虚地址">#</a> 1、实地址与虚地址</h4><ul><li>用户<strong>编制程序</strong>时使用的地址称为<strong>虚地址或逻辑地址</strong>，其对应的存储空间称为<strong>虚存空间或逻辑地址空间</strong></li><li>计算<strong>机物理内存</strong>的访问地址则称为<strong>实地址或物理地址</strong>，其对应的存储空间称为<strong>物理存储空间或主存空间</strong>。</li><li><strong>程序进行虚地址到实地址转换的过程称为程序的重定位</strong>。</li></ul><h4 id="2-虚存的访问过程"><a class="anchor" href="#2-虚存的访问过程">#</a> 2、虚存的访问过程</h4><ul><li>虚存空间的用户程序按照虚地址编程并存放在<strong>辅存</strong>中。程序运行时，<strong>由地址变换机构</strong>依据当时分配给该程序的实地址空间把程序的一部分<strong>调入实存</strong>。</li><li>每次访存时，首先判断该虚地址所对应的部分是否在实存中：<ul><li>如果是，则进行地址转换并用实地址访问主存；</li><li>否则，按照某种算法将辅存中的部分程序调度进内存，再按同样的方法访问主存。</li></ul></li><li>由此可见，每个程序的虚地址空间可以远大于实地址空间，也可以远小于实地址空间。<ul><li>前一种情况以<strong>提高存储容量</strong>为目的，后一种情况则以<strong>地址变换</strong>为目的。</li><li>后者通常出现在多用户或多任务系统中：实存空间较大，而单个任务并不需要很大的地址空间，较小的虚存空间则可以<strong>缩短指令地址字段长度</strong>。</li></ul></li><li>每个程序就可以拥有一个虚拟的存储器，它具有<strong>辅存的容量</strong>和<strong>接近主存的访问速度</strong>。但这个虚存是由主存和辅存以及辅存管理部件构成的概念模型，不是实际的物理存储器。虚存是在主存和辅存之外附加一些硬件和软件实现的。</li></ul><h4 id="3-cache与虚存的异同"><a class="anchor" href="#3-cache与虚存的异同">#</a> 3、cache 与虚存的异同</h4><ul><li>从虚存的概念可以看出，主存 - 辅存的访问机制与 cache - 主存的访问机制是类似的。这是由 cache 存储器、主存和辅存构成的三级存储体系中的两个层次。</li><li>cache 和主存之间以及主存和辅存之间分别有辅助硬件和辅助软硬件负责地址变换与管理，以便各级存储器能够组成有机的三级存储体系。</li><li><strong>cache 和主存构成了系统的内存，而主存和辅存依靠辅助软硬件的支持构成了虚拟存储器。</strong></li></ul><p>在三级存储体系中，cache - 主存和主存 - 辅存这两个存储层次有许多相同点；</p><ul><li><strong>出发点相同</strong> 二者都是为了<strong>提高存储系统的性能价格比</strong>而构造的分层存储体系，都力图使存储系统的性能接近高速存储器，而价格和容量接近低速存储器</li><li><strong>原理相同</strong> 都是<strong>利用了程序运行时的局部性原理</strong>把最近常用的信息块从相对慢速而大容量的存储器调入相对高速而小容量的存储器。</li></ul><p>但 cache - 主存和主存 - 辅存这两个存储层次也有许多不同之处:</p><ul><li><strong>侧重点不同</strong> <strong>cache 主要解决主存与 CPU 的速度差异问题</strong>；而就性能价格比的提高而言，<strong>虚存主要是解决存储容量问题</strong>，另外还包括存储管理、主存分配和存储保护等方面。</li><li><strong>数据通路不同</strong> <strong>CPU 与 cache 和主存之间均有直接访问通路</strong>，cache 不命中时可直接访问主存；而<strong>虚存所依赖的辅存与 CPU 之间不存在直接的数据通路</strong>，当主存不命中时只能通过调页解决，CPU 最终还是要访问主存。</li><li><strong>透明性不同</strong> <strong>cache 的管理完全由硬件完成，对系统程序员和应用程序员均透明</strong>；而虚存管理由软件（操作系统）和硬件共同完成，由于软件的介入，<strong>虚存对</strong>实现存储管理的<strong>系统程序员不透明，而只对应用程序员透明</strong>（段式和段页式管理对应用程序员 “半透明”）。</li><li><strong>未命中时的损失不同</strong> 由于主存的存取时间是 cache 的存取时间的 5～10 倍，而<strong>主存的存取速度通常比辅存的存取速度快上千倍</strong>，故<strong>主存未命中时系统的性能损失要远大于 cache 未命中时的损失</strong>。</li></ul><h4 id="4-虚存机制要解决的关键问题"><a class="anchor" href="#4-虚存机制要解决的关键问题">#</a> 4、虚存机制要解决的关键问题</h4><ul><li><strong>调度问题</strong> —— 决定哪些程序和数据应被调入主存。</li><li><strong>地址映射问题</strong> —— 在访问主存时把虚地址变为主存物理地址（这一过程称为<strong>内地址变换</strong>），在访问辅存时把虚地址变成辅存的物理地址（这一过程称为<strong>外地址变换</strong>），以便换页。此外还要解决主存分配、存储保护与程序再定位等问题。</li><li><strong>替换问题</strong> —— 决定哪些程序和数据应被调出主存。</li><li><strong>更新问题</strong> —— 确保<strong>主存与辅存的一致性</strong>。在操作系统的控制下，硬件和系统软件为用户解决了上述问题，从而使应用程序的编程大大简化。</li></ul><h3 id="372-页式虚拟存储器"><a class="anchor" href="#372-页式虚拟存储器">#</a> 3.7.2 页式虚拟存储器</h3><h4 id="1-页式虚存地址映射"><a class="anchor" href="#1-页式虚存地址映射">#</a> 1、页式虚存地址映射</h4><ul><li>页式虚拟存储系统中，虚地址空间被分成等长大小的页，称为<strong>逻辑页</strong>；</li><li>主存空间也被分成同样大小的页，称为<strong>物理页</strong>。</li><li>虚地址分为两个字段：<strong>高字段为逻辑页号，低字段为页内地址（偏移量）</strong>；</li><li>实存地址也分两个字段：<strong>高字段为物理页号，低字段为页内地址。</strong></li><li>通过<strong>页表</strong>可以把虚地址（逻辑地址）转换成物理地址。页式虚拟存储器的地址映射过程见下图。<img data-src="https://img-blog.csdnimg.cn/20210617193837358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>在大多数系统中，每个进程对应一个页表。页表中对应每一个虚存页面有一个表项，表项的内容包含该虚存页面所在的主存页面的地址（物理页号），以及指示该逻辑页是否已调入主存的有效位。</li><li>地址变换时，<strong>用逻辑页号作为页表内的偏移地址索引页表（将虚页号看作页表数组下标）并找到相应物理页号，用物理页号作为实存地址的高字段，再与虚地址的页内偏移量拼接</strong>，就构成完整的物理地址。</li><li>每个进程所需的页数并不固定，所以页表的长度是可变的，因此通常的实现方法是把页表的基地址保存在寄存器中，而页表本身则放在主存中。由于虚存地址空间可以很大，因而每个进程的页表有可能非常长为了节省页表本身占用的主存空间，一些系统把页表存储在虚存中，因而页表本身也要进行分页。</li><li>当一个进程运行时，其页表中一部分在主存中，另一部分则在辅存中保存。</li><li>另一些系统采用<strong>二级页表</strong>结构。每个进程有一个页目录表，其中的每个表项指向一个页表。因此，<strong>若页目录表的长度（表项数）是 m, 每个页表的最大长度（表项数）为 n, 则一个进程最多可以有 m×n 个页。</strong></li><li>在页表长度较大的系统中，还可以采用反向页表实现物理页号到逻辑页号的反向映射。</li></ul><h4 id="2-转换后援缓冲器快表tlb"><a class="anchor" href="#2-转换后援缓冲器快表tlb">#</a> 2、转换后援缓冲器（快表 TLB）</h4><ul><li>由于页表通常在主存中，因而即使逻辑页已经在主存中，也至少要访问两次物理存储器才能实现一次访存，这将使虚拟存储器的存取时间加倍。</li><li>为了避免对主存访问次数的增多，可以对页表本身实行二级缓存，把页表中的最活跃的部分存放在高速存储器中，组成<strong>快表</strong>。</li><li>这个专用于页表缓存的高速存储部件通常称为<strong>转换后援缓冲器 (TLB)</strong>。</li><li>保存在主存中的完整页表则称为<strong>慢表</strong>。</li><li>TLB（快表）的地址映射过程见图</li><li><img data-src="https://img-blog.csdnimg.cn/20210617194507114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h4 id="3-内页表和外页表"><a class="anchor" href="#3-内页表和外页表">#</a> 3、内页表和外页表</h4><ul><li>页表是<strong>虚地址到主存</strong>物理地址的变换表，通常称为内页表。</li><li>外页表：用于<strong>虚地址与辅存</strong>地址之间的变换。</li><li>当主存缺页时，调页操作首先要定位辅存，而外页表的结构与辅存的寻址机制密切相关。<ul><li>例如对磁盘而言，辅存地址包括磁盘机号、磁头号、磁道号和扇区号等。</li></ul></li></ul><p>页式存储主要优点：</p><ul><li>主存储器的利用率比较高</li><li>页表相对比较简单</li><li>地址变换的速度比较快</li><li>对磁盘的管理比较容易</li></ul><p>主要缺点：</p><ul><li>程序的模块化性能不好</li><li>页表很长，需要占用很大的存储空间</li></ul><h3 id="373-段式虚拟存储器和段页式虚拟存储器"><a class="anchor" href="#373-段式虚拟存储器和段页式虚拟存储器">#</a> 3.7.3 段式虚拟存储器和段页式虚拟存储器</h3><h4 id="1-段式虚拟存储器"><a class="anchor" href="#1-段式虚拟存储器">#</a> 1、段式虚拟存储器</h4><ul><li><strong>段是按照程序的自然分界划分的长度可以动态改变的区域。</strong></li><li>程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。</li><li>在段式虚拟存储系统中，<strong>虚地址由段号和段内地址（偏移量）组成。<strong>虚地址到实主存地址的变换通过</strong>段表</strong>实现。</li><li>每个程序设置一个段表，段表的每一个表项对应一个段。每个表项至少包含下面三个字段：<ul><li><strong>有效位</strong>：指明该段是否已经调入实存。</li><li><strong>段起址</strong>：指明在该段已经调入实存的情况下，该段在实存中的首地址。</li><li><strong>段长</strong>：记录该段的实际长度。设置段长字段的目的是为了保证访问某段的地址空间时，段内地址不会超出该段长度导致地址越界而破坏其他段。 段表本身也是一个段，可以存在辅存中，但一般是驻留在主存中。</li></ul></li></ul><p>段式虚地址向实存地址的变换过程<br><img data-src="https://img-blog.csdnimg.cn/20210617195345818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>段式虚拟存储器有许多优点：</p><ul><li>①段的<strong>逻辑独立性</strong>使其易于编译、管理、修改和保护，也<strong>便于多道程序共享</strong>。</li><li>②<strong>段长可以根据需要动态改变</strong>，允许自由调度，以便有效利用主存空间。<br>缺点：</li><li>①因为段的长度不固定，<strong>主存空间分配比较麻烦</strong>。</li><li>②容易在段间留下许多<strong>外部碎片</strong>，造成存储空间利用率降低。</li><li>③由于段长不一定是 2 的整数次幂，因而不能简单地像分页方式那样用虚地址和实地址的最低若干二进制位作为段内偏移量，并与段号进行直接拼接，必须用加法操作通过段起址与段内偏移量的求和运算求得物理地址。因此，段式存储管理比页式存储管理方式<strong>需要更多的硬件支持</strong>。</li></ul><h4 id="2-段页式虚拟存储器"><a class="anchor" href="#2-段页式虚拟存储器">#</a> 2、段页式虚拟存储器</h4><ul><li>段页式虚拟存储器是段式虚拟存储器和页式虚拟存储器的结合。<strong>实存被等分成页。每个程序则先按逻辑结构分段，每段再按照实存的页大小分页</strong>，程序按页进行调入和调出操作，但可按段进行编程、保护和共享。</li></ul><p>[例 1] 假设有三道程序，基号用 A、B 和 C 表示，其基址寄存器的内容分别为 S<sub>A</sub>、S<sub>B</sub> 和 S<sub>C</sub>。程序 A 由 4 个段构成，程序 C 由 3 个段构成。段页式虚拟存储系统的逻辑地址到物理地址的变换过程如图所示。在主存中，每道程序都有一张段表，A 程序有 4 段，C 程序有 3 段，每段应有一张页表，段表的每行就表示相应页表的起始位置，而页表内的每行即为相应的物理页号。请说明虚实地址变换过程。<img data-src="https://img-blog.csdnimg.cn/20210617200047485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>解：地址变换过程如下：<br>（1）由存储管理部件根据基号 C 找到段表基址寄存器表第 c 个 表项，获得程序 C 的段表基址 SC。再根据段号 S (=1) 找到 程序 C 段表的第 S 个表项，得到段 S 的页表起始地址 b。<br>（2）根据段内逻辑页号 P (=2) 检索页表，得到物理页号（图中 为 10）。<br>（3）物理页号与页内地址偏移量拼接即得物理地址。 假如计算机系统中只有一个基址寄存器，则基号可不要。 多道程序切换时，由操作系统修改基址寄存器内容。</p><p>可以看出，段页式虚拟存储器的缺点是在由虚地址向主存地址的映射过程中需要多次查表，因而实现复杂度较高．</p><h3 id="374-虚存的替换算法"><a class="anchor" href="#374-虚存的替换算法">#</a> 3.7.4 虚存的替换算法</h3><p>当从辅存调页至主存而主存已满时，也需要进行主存页面的替换。虚拟存储器的替换算法与 cache 的替换算法类似：有 FIFO 算法、LRU 算法、LFU 算法等。</p><p>虚拟存储器的替换算法与 cache 的替换算法不同的是：</p><ul><li>（1）cache 的替换全部靠硬件实现，而虚拟存储器的替换有操作系统的支持。</li><li>（2）虚存缺页对系统性能的影响比 cache 未命中要大得多，因为调页需要访问辅存，并且要进行任务切换。</li><li>（3）虚存页面替换的选择余地很大，属于一个进程的任何页面都可替换。</li></ul><h2 id="本章小结"><a class="anchor" href="#本章小结">#</a> 本章小结</h2><ul><li>对存储器的要求是容量大、速度快、成本低。为了解决了这三方面的矛盾，计算机采用<strong>多级存储体系结构</strong>，即 cache、主存和外存。CPU 能直接方问内存 (cache、主存），但不能直接访问外存。<strong>存储器的技术指标</strong>有存储容量、存取时间、存储周期、存储器带宽。</li><li>广泛使用的<strong> SRAM 和 DRAM</strong> 都是半导体随机读写存储器，前者速度比后者快，但集成度不如后者高。二者的优点是体积小，可靠性高，价格低廉，缺点是断电后不能保存信息。</li><li><strong>只读存储器和闪速存储器</strong>正好弥补了 SRAM 和 DRAM 的缺点，即使断电也仍然保存原先写入的数据。特别是闪速存储器能提供高性能、低功耗、高可靠性以及移动性，是一种全新的存储器体系结构。</li><li><strong>双端口存储器和多模块交叉存储器</strong>属于并行存储器结构。前者采用空间并行技术，后者采用时间并行技术。这两种类型的存储器在科研和工程中大量使用。</li><li>cache 是一种高速缓冲存储器，是为了解决 CPU 和主存之间速度不匹配而采用的一项重要的硬件技术，并且发展为多级 cache 体系，指令 cache 与数据 cache 分设体系。要求 cache 的命中率接近于 1。主存与 cache 的地址映射有<strong>全相联、直接、组相联</strong>三种方式。其中组相联方式是前二者的折衷方案，适度地兼顾了二者的优点又尽量避免其缺点，从灵活性、命中率、硬件投资来说较为理想，因而得到了普遍采用。</li><li>用户程序按照虚地址（逻辑地址）编程并存放在辅存中。程序运行时，由地址变换机构依据当时分配给该程序的实地址空间把程序的一部分调入实存（物理存储空间或主存空间）。由操作系统在硬件的支持下对程序进行虚地址到实地址的变换，这一过程称为程序的再定位。<strong>每次访存时，首先判断该虚地址所对应的部分是否在实存中：如果是，则进行地址转换并用实地址访问主存；否则，按照某种算法将辅存中的部分程序调度进内存，再按同样的方法访问主存。</strong> 对应用程序而言，如果主存的命中率很高，虚存的访问时间就接近于主存访问时间，而虚存的大小仅仅依赖于辅存的大小。</li><li>虚存机制也要解决一些关键问题，包括<strong>调度问题、地址映射问题和替换问题</strong>等。在操作系统的控制下，硬件和系统软件为用户解决了上述问题，从而使应用程序的编程大大简化。</li><li><strong>页式虚拟存储系统</strong>中，虚地址空间和主存空间都被分成大小相等的页，通过页表可以把虚地址转换成物理地址。为了避免对主存访问次数的增多，可以对页表本身实行二级缓存，把页表中的最活跃部分存放在转换后援缓冲器（TLB）中。</li><li>分页方式的缺点是页长与程序的逻辑大小不相关，而分段方式则可按照程序的自然分界将内存空间划分为长度可以动态改变的存储区域。在<strong>段式虚拟存储系统</strong>中，虚地址由段号和段内地址（偏移量）组成。虚地址到实主存地址的变换通过<strong>段表</strong>实现。</li><li><strong>段页式虚拟存储器</strong>是段式虚拟存储器和页式虚拟存储器的结合，<strong>程序按页进行调入和调出操作，但可按段进行编程、保护和共享。</strong> 虚拟存储器还解决存储保护等问题。在虚拟存储系统中，通常采用页表保护、段表保护和键式保护方法实现存储区域保护。还可以结合对主存信息的使用方式实现访问方式保护。</li></ul><div class="tags"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag"><i class="ic i-tag"></i> 计算机组成原理</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-05-07 01:03:01" itemprop="dateModified" datetime="2022-05-07T01:03:01+08:00">2022-05-07</time> </span><span id="计算机组成原理复习总结（三）多层次的存储器/" class="item leancloud_visitors" data-flag-title="计算机组成原理复习总结（三）多层次的存储器" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/img/wechatpay.png" alt="cos 微信支付"><p>微信支付</p></div><div><img data-src="/img/alipay.png" alt="cos 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>cos <i class="ic i-at"><em>@</em></i>余弦の博客</li><li class="link"><strong>本文链接：</strong> <a href="https://ysx.cosine.ren/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89%E5%A4%9A%E5%B1%82%E6%AC%A1%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8/" title="计算机组成原理复习总结（三）多层次的存储器">https://ysx.cosine.ren/计算机组成原理复习总结（三）多层次的存储器/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/" itemprop="url" rel="prev" data-background-image="&#x2F;img&#x2F;header_img&#x2F;lml_bg.jpg" title="计算机组成原理复习总结（二）运算方法和运算器"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> CS 基础</span><h3>计算机组成原理复习总结（二）运算方法和运算器</h3></a></div><div class="item right"><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="next" data-background-image="&#x2F;img&#x2F;header_img&#x2F;lml_bg.jpg" title="计算机组成原理复习总结（四）指令系统"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> CS 基础</span><h3>计算机组成原理复习总结（四）指令系统</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%A4%9A%E5%B1%82%E6%AC%A1%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">第三章 多层次的存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">3.1 存储器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#311-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">3.1.1 存储器的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#312-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%BA%A7"><span class="toc-number">1.1.2.</span> <span class="toc-text">3.1.2 存储器的分级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#313%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.1.3 主存储器的技术指标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-sram%E5%AD%98%E5%82%A8%E5%99%A8%E9%9D%99%E6%80%81%E8%AF%BB%E5%86%99%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">3.2 SRAM 存储器（静态读写存储器）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#321-%E5%9F%BA%E6%9C%AC%E7%9A%84%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%85%83%E9%98%B5%E5%88%97"><span class="toc-number">1.2.1.</span> <span class="toc-text">3.2.1 基本的静态存储元阵列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#322-%E5%9F%BA%E6%9C%AC%E7%9A%84sram%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">3.2.2 基本的 SRAM 逻辑结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#323-%E8%AF%BB%E5%86%99%E5%91%A8%E6%9C%9F%E6%B3%A2%E5%BD%A2%E5%9B%BE"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.2.3 读 &#x2F; 写周期波形图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-dram%E5%AD%98%E5%82%A8%E5%99%A8%E5%8A%A8%E6%80%81%E8%AF%BB%E5%86%99%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">3.3 DRAM 存储器（动态读写存储器）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#333-%E8%AF%BB%E5%86%99%E5%91%A8%E6%9C%9F-%E5%88%B7%E6%96%B0%E5%91%A8%E6%9C%9F%E9%87%8D%E7%82%B9"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.3.3 读 &#x2F; 写周期、刷新周期（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">读 &#x2F; 写周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">刷新周期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%88%B7%E6%96%B0"><span class="toc-number">1.3.1.2.1.</span> <span class="toc-text">集中式刷新</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%95%A3%E5%BC%8F%E5%88%B7%E6%96%B0"><span class="toc-number">1.3.1.2.2.</span> <span class="toc-text">分散式刷新</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8rom%E5%92%8C%E9%97%AA%E9%80%9F%E5%AD%98%E5%82%A8%E5%99%A8flash"><span class="toc-number">1.4.</span> <span class="toc-text">3.4 只读存储器（ROM）和闪速存储器 (FLASH)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8E%A9%E6%A8%A1rommrom"><span class="toc-number">1.4.1.</span> <span class="toc-text">1、掩模 ROM（MROM)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%AF%E7%BC%96%E7%A8%8Brom"><span class="toc-number">1.4.2.</span> <span class="toc-text">2、可编程 ROM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-flash%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">3、FLASH 存储器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E5%B9%B6%E8%A1%8C%E5%AD%98%E5%82%A8%E5%99%A8%E9%87%8D%E7%82%B9"><span class="toc-number">1.5.</span> <span class="toc-text">3.5 并行存储器（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#351-%E5%8F%8C%E7%AB%AF%E5%8F%A3%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">3.5.1 双端口存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%8C%E7%AB%AF%E5%8F%A3%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">1、双端口存储器的逻辑结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%97%A0%E5%86%B2%E7%AA%81%E8%AF%BB%E5%86%99%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">2、无冲突读写控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9C%89%E5%86%B2%E7%AA%81%E8%AF%BB%E5%86%99%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">3、有冲突读写控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#352%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%BA%A4%E5%8F%89%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">3.5.2 多模块交叉存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BB%84%E7%BB%87"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">1、存储器的模块化组织</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%9A%E6%A8%A1%E5%9D%97%E4%BA%A4%E5%8F%89%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">2、多模块交叉存储器的基本结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-cache%E5%AD%98%E5%82%A8%E5%99%A8%E9%87%8D%E7%82%B9"><span class="toc-number">1.6.</span> <span class="toc-text">3.6 cache 存储器（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#361-cache%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.1.</span> <span class="toc-text">3.6.1 cache 基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-cache%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">1、cache 的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BF%E9%97%AE%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.1.1.1.</span> <span class="toc-text">程序访问的局部性原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-cache%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">2、cache 基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-cache%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">3、cache 结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%91%BD%E4%B8%AD%E4%B8%8E%E6%9C%AA%E5%91%BD%E4%B8%AD"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">4、命中与未命中</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#362-%E4%B8%BB%E5%AD%98%E4%B8%8Ecache%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-number">1.6.2.</span> <span class="toc-text">3.6.2 主存与 cache 的地址映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">全相联映射方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">直接映射方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F%E7%9A%84%E6%A3%80%E7%B4%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.2.2.1.</span> <span class="toc-text">直接映射方式的检索过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">组相联映射方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#363-%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">1.6.3.</span> <span class="toc-text">3.6.3 替换策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%B8%8D%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8lfu%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">最不经常使用 (LFU) 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%91%E6%9C%9F%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8lru%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">近期最少使用 (LRU) 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">随机替换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E9%87%8D%E7%82%B9"><span class="toc-number">1.7.</span> <span class="toc-text">3.7 虚拟存储器（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#371-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.1.</span> <span class="toc-text">3.7.1 虚拟存储器的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9E%E5%9C%B0%E5%9D%80%E4%B8%8E%E8%99%9A%E5%9C%B0%E5%9D%80"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">1、实地址与虚地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%99%9A%E5%AD%98%E7%9A%84%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">2、虚存的访问过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-cache%E4%B8%8E%E8%99%9A%E5%AD%98%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">3、cache 与虚存的异同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%99%9A%E5%AD%98%E6%9C%BA%E5%88%B6%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">4、虚存机制要解决的关键问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#372-%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.7.2.</span> <span class="toc-text">3.7.2 页式虚拟存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%B5%E5%BC%8F%E8%99%9A%E5%AD%98%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">1、页式虚存地址映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BD%AC%E6%8D%A2%E5%90%8E%E6%8F%B4%E7%BC%93%E5%86%B2%E5%99%A8%E5%BF%AB%E8%A1%A8tlb"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">2、转换后援缓冲器（快表 TLB）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%86%85%E9%A1%B5%E8%A1%A8%E5%92%8C%E5%A4%96%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">3、内页表和外页表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#373-%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E5%92%8C%E6%AE%B5%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.7.3.</span> <span class="toc-text">3.7.3 段式虚拟存储器和段页式虚拟存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">1、段式虚拟存储器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">2、段页式虚拟存储器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#374-%E8%99%9A%E5%AD%98%E7%9A%84%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.4.</span> <span class="toc-text">3.7.4 虚存的替换算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">本章小结</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B/" rel="bookmark" title="操作系统编程实验——创建进程">操作系统编程实验——创建进程</a></li><li><a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%A8%A1%E6%8B%9F/" rel="bookmark" title="操作系统实验——动态分区分配方式的模拟">操作系统实验——动态分区分配方式的模拟</a></li><li><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/" rel="bookmark" title="计算机组成原理复习总结（一）计算机系统概论">计算机组成原理复习总结（一）计算机系统概论</a></li><li><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/" rel="bookmark" title="计算机组成原理复习总结（二）运算方法和运算器">计算机组成原理复习总结（二）运算方法和运算器</a></li><li class="active"><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89%E5%A4%9A%E5%B1%82%E6%AC%A1%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8/" rel="bookmark" title="计算机组成原理复习总结（三）多层次的存储器">计算机组成原理复习总结（三）多层次的存储器</a></li><li><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" rel="bookmark" title="计算机组成原理复习总结（四）指令系统">计算机组成原理复习总结（四）指令系统</a></li><li><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AD%EF%BC%89%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/" rel="bookmark" title="计算机组成原理复习总结（六）总线系统">计算机组成原理复习总结（六）总线系统</a></li><li><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%83%EF%BC%89%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/" rel="bookmark" title="计算机组成原理复习总结（七）外围设备">计算机组成原理复习总结（七）外围设备</a></li><li><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/" rel="bookmark" title="计算机组成原理复习总结（五）中央处理器">计算机组成原理复习总结（五）中央处理器</a></li><li><a href="/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%B0%8F%E6%B5%8B/" rel="bookmark" title="软件工程期末小测">软件工程期末小测</a></li><li><a href="/compile-learning-experiment_1/" rel="bookmark" title="编译原理 实验一 词法分析器设计">编译原理 实验一 词法分析器设计</a></li><li><a href="/compile-learning-experiment_2/" rel="bookmark" title="编译原理 实验二 LL(1)分析法程序">编译原理 实验二 LL(1)分析法程序</a></li><li><a href="/compile-learning-experiment_4/" rel="bookmark" title="编译原理 实验四 LR(1)分析法程序">编译原理 实验四 LR(1)分析法程序</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="cos" data-src="/img/avatar.jpg"><p class="name" itemprop="name">cos</p><div class="description" itemprop="description">愿岁并谢，与友长兮</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">141</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">21</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">96</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3l1c2l4aWFu" title="https:&#x2F;&#x2F;github.com&#x2F;yusixian"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9xaS1qaXUtZW4=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;qi-jiu-en"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTM2MTAyOTgwNA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;361029804"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmNvc2luZV95dUBxcS5jb20=" title="mailto:cosine_yu@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/coding-train/" title="分类于 题目记录">题目记录</a> <i class="ic i-angle-right"></i> <a href="/categories/coding-train/offer/" title="分类于 剑指 offer">剑指 offer</a></div><span><a href="/coding-train/leetcode/offer/day1" title="剑指offer day1 栈与队列（简单）">剑指offer day1 栈与队列（简单）<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/coding-train/" title="分类于 题目记录">题目记录</a></div><span><a href="/PTA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E9%9B%86%20%E7%AC%AC%E5%85%AD%E5%91%A8%E2%80%94%E2%80%94%E5%9B%BE%EF%BC%88%E4%B8%8A%EF%BC%89" title="PTA数据结构题目集 第六周——图（上）">PTA数据结构题目集 第六周——图（上）<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/note/" title="分类于 笔记">笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/note/data-structure/" title="分类于 数据结构">数据结构</a></div><span><a href="/%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%B0%81%E8%A3%85(1)%E2%80%94%E2%80%94%E5%8D%95%E9%93%BE%E8%A1%A8" title="模板类封装(1)——单链表">模板类封装(1)——单链表<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/coding-train/" title="分类于 题目记录">题目记录</a> <i class="ic i-angle-right"></i> <a href="/categories/coding-train/bytedance/" title="分类于 字节校园">字节校园</a></div><span><a href="/coding-train/leetcode/bytedance/bytedance-day17" title="冲刺春招-精选笔面试66题大通关17">冲刺春招-精选笔面试66题大通关17<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/coding-train/" title="分类于 题目记录">题目记录</a> <i class="ic i-angle-right"></i> <a href="/categories/coding-train/bytedance/" title="分类于 字节校园">字节校园</a></div><span><a href="/coding-train/leetcode/bytedance/bytedance-day13" title="冲刺春招-精选笔面试66题大通关day13">冲刺春招-精选笔面试66题大通关day13<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/note/" title="分类于 笔记">笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/note/bytedance-note/" title="分类于 青训营笔记">青训营笔记</a></div><span><a href="/note/front-end/bytedance-note/webpack-knowledge-system" title="【第二届青训营-寒假前端场】- 「构建Webpack知识体系」">【第二届青训营-寒假前端场】- 「构建Webpack知识体系」<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/coding-train/" title="分类于 题目记录">题目记录</a> <i class="ic i-angle-right"></i> <a href="/categories/coding-train/offer/" title="分类于 剑指 offer">剑指 offer</a></div><span><a href="/coding-train/leetcode/offer/day11" title="剑指offer day11 双指针（简单）">剑指offer day11 双指针（简单）<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/coding-train/" title="分类于 题目记录">题目记录</a> <i class="ic i-angle-right"></i> <a href="/categories/coding-train/offer/" title="分类于 剑指 offer">剑指 offer</a></div><span><a href="/coding-train/leetcode/offer/day20" title="剑指offer day20 分治算法（中等）">剑指offer day20 分治算法（中等）<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/coding-train/" title="分类于 题目记录">题目记录</a> <i class="ic i-angle-right"></i> <a href="/categories/coding-train/offer/" title="分类于 剑指 offer">剑指 offer</a></div><span><a href="/coding-train/leetcode/offer/day22" title="剑指offer day22 位运算（中等）">剑指offer day22 位运算（中等）<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/note/" title="分类于 笔记">笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/note/front-end/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/note/front-end/react/" title="分类于 React">React</a></div><span><a href="/react-learning-1" title="React学习小记">React学习小记<i class="ic i-link-alt"></i></a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">cos @ cosine</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">619k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">9:23</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"计算机组成原理复习总结（三）多层次的存储器/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->